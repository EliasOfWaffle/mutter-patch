From 50f565dc32a0ac511d12053a1bb1cb22ebf43e44 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Jonas=20=C3=85dahl?= <jadahl@gmail.com>
Date: Thu, 25 Aug 2016 17:38:45 +0800
Subject: [PATCH] wayland/cursor-role: Increase buffer use count on
 construction

We may be assigned multiple times, if the surface is assigned to be a
cursor surface multiple times. Each time e.g. wl_pointer.set_cursor is
called, we'll be assigned.

While the role object exists, we'll handle buffer use count even when
we are not actively assigned, thus we should only handle the initial
assignment use count bump when constructing, so that we don't increase
it when reassigned, where the wl_resource may already have been
released.

https://bugzilla.gnome.org/show_bug.cgi?id=770402
---
 src/wayland/meta-wayland-surface-role-cursor.c | 34 +++++++++++++++++---------
 1 file changed, 23 insertions(+), 11 deletions(-)

diff --git a/src/wayland/meta-wayland-surface-role-cursor.c b/src/wayland/meta-wayland-surface-role-cursor.c
index 2dbbc55..d63aed4 100644
--- a/src/wayland/meta-wayland-surface-role-cursor.c
+++ b/src/wayland/meta-wayland-surface-role-cursor.c
@@ -110,19 +110,8 @@ cursor_sprite_prepare_at (MetaCursorSprite             *cursor_sprite,
 static void
 cursor_surface_role_assigned (MetaWaylandSurfaceRole *surface_role)
 {
-  MetaWaylandSurfaceRoleCursor *cursor_role =
-    META_WAYLAND_SURFACE_ROLE_CURSOR (surface_role);
-  MetaWaylandSurfaceRoleCursorPrivate *priv =
-    meta_wayland_surface_role_cursor_get_instance_private (cursor_role);
   MetaWaylandSurface *surface =
     meta_wayland_surface_role_get_surface (surface_role);
-  MetaWaylandBuffer *buffer = meta_wayland_surface_get_buffer (surface);
-
-  if (buffer)
-    {
-      g_set_object (&priv->buffer, buffer);
-      meta_wayland_surface_ref_buffer_use_count (surface);
-    }
 
   meta_wayland_surface_queue_pending_frame_callbacks (surface);
 }
@@ -213,6 +202,28 @@ cursor_surface_role_dispose (GObject *object)
 }
 
 static void
+cursor_surface_role_constructed (GObject *object)
+{
+  MetaWaylandSurfaceRoleCursor *cursor_role =
+    META_WAYLAND_SURFACE_ROLE_CURSOR (object);
+  MetaWaylandSurfaceRoleCursorPrivate *priv =
+    meta_wayland_surface_role_cursor_get_instance_private (cursor_role);
+  MetaWaylandSurfaceRole *surface_role =
+    META_WAYLAND_SURFACE_ROLE (cursor_role);
+  MetaWaylandSurface *surface =
+    meta_wayland_surface_role_get_surface (surface_role);
+  MetaWaylandBuffer *buffer;
+
+  buffer = meta_wayland_surface_get_buffer (surface);
+  if (buffer)
+    {
+      g_assert (buffer->resource);
+      g_set_object (&priv->buffer, buffer);
+      meta_wayland_surface_ref_buffer_use_count (surface);
+    }
+}
+
+static void
 meta_wayland_surface_role_cursor_init (MetaWaylandSurfaceRoleCursor *role)
 {
   MetaWaylandSurfaceRoleCursorPrivate *priv =
@@ -238,6 +249,7 @@ meta_wayland_surface_role_cursor_class_init (MetaWaylandSurfaceRoleCursorClass *
   surface_role_class->commit = cursor_surface_role_commit;
   surface_role_class->is_on_output = cursor_surface_role_is_on_output;
 
+  object_class->constructed = cursor_surface_role_constructed;
   object_class->dispose = cursor_surface_role_dispose;
 }
 
-- 
2.9.3

